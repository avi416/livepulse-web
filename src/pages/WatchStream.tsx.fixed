import { useEffect, useRef, useState } from 'react';
import { useParams, Link } from 'react-router-dom';
import { doc, onSnapshot } from 'firebase/firestore';
import { getFirestoreInstance } from '../services/firebase';
import { connectAsViewer, connectAsCoHost } from '../services/webrtcService';
import type { LiveStreamDoc } from '../services/liveStreams';
import UserAvatar from '../components/UserAvatar';
import { RequestToJoinButton, LeaveLiveButton } from '../components/cohost';
import { subscribeToCurrentUserRequest } from '../services/streamService';
import { useLocalMedia } from '../hooks/useLocalMedia';

export default function WatchStream() {
  const { id } = useParams<{ id: string }>();
  const videoRef = useRef<HTMLVideoElement | null>(null);
  const containerRef = useRef<HTMLDivElement | null>(null);
  const [videoReady, setVideoReady] = useState(false);
  const [streamData, setStreamData] = useState<LiveStreamDoc | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [isConnected, setIsConnected] = useState(false);
  const [connectionStatus, setConnectionStatus] = useState<string>('Waiting for stream...');
  const cleanupRef = useRef<(() => void) | null>(null);
  const connectingRef = useRef(false);

  // Co-host specific state
  const [joinRequest, setJoinRequest] = useState<any>(null);
  const [isCoHost, setIsCoHost] = useState(false);
  const [coHostCleanup, setCoHostCleanup] = useState<(() => void) | null>(null);
  const { videoRef: localVideoRef, stream: localStream, start: startLocalMedia, stop: stopLocalMedia } = useLocalMedia();

  // Monitor join request status
  useEffect(() => {
    if (!id || !streamData || streamData.status !== 'live') return;

    const unsubscribe = subscribeToCurrentUserRequest(id, (request) => {
      setJoinRequest(request);
      
      // If request was approved, start co-host connection
      if (request?.status === 'approved' && !isCoHost) {
        handleCoHostConnect();
      }
      
      // If request was rejected or cancelled, clean up co-host connection
      if ((request?.status === 'rejected' || request?.status === 'cancelled') && isCoHost) {
        cleanupCoHostConnection();
      }
    });

    return () => unsubscribe();
  }, [id, streamData, isCoHost]);

  // Start co-host connection when approved
  const handleCoHostConnect = async () => {
    if (!id || !streamData || streamData.status !== 'live') return;
    
    try {
      setConnectionStatus('Starting co-host connection...');
      
      // Make sure we have local media
      if (!localStream) {
        console.log('üé• Starting local media for co-host connection...');
        try {
          await startLocalMedia();
          console.log('‚úÖ Local media started successfully');
          
          // Wait a bit to ensure stream is fully initialized
          await new Promise(resolve => setTimeout(resolve, 1000));
        } catch (mediaError: any) {
          console.error('‚ùå Failed to get camera/microphone access:', mediaError);
          setConnectionStatus(`Failed to access camera/microphone: ${mediaError.message || 'Permission denied'}`);
          return;
        }
      }
      
      // Wait for local stream to be actually available
      let attempts = 0;
      const maxAttempts = 5;
      while (!localStream && attempts < maxAttempts) {
        console.log(`‚è≥ Waiting for local stream to be ready... (attempt ${attempts + 1}/${maxAttempts})`);
        await new Promise(resolve => setTimeout(resolve, 1000));
        attempts++;
      }
      
      if (!localStream) {
        console.error('‚ùå Local stream is still null after waiting');
        throw new Error('Failed to get local media for co-host - stream is null');
      }
      
      // Log track information to debug
      const trackInfo = localStream.getTracks().map(t => ({
        kind: t.kind,
        enabled: t.enabled,
        muted: t.muted,
        readyState: t.readyState,
        id: t.id
      }));
      
      console.log('üé• Local media ready with tracks:', trackInfo);
      
      if (trackInfo.length === 0) {
        console.error('‚ùå No tracks in local stream');
        throw new Error('No camera/microphone tracks available');
      }
      
      // Show connecting indicator
      setConnectionStatus('Connecting to host as co-host...');
      
      // Add timeout to abort if taking too long
      const timeoutPromise = new Promise((_, reject) => {
        setTimeout(() => reject(new Error('Connection timeout - taking too long to connect')), 60000);
      });
      
      // Check if the video element is available
      if (!videoRef.current) {
        console.error('‚ùå Video element is not available for co-host connection');
        throw new Error('Video element not ready');
      }
      
      console.log('üì° Attempting to connect as co-host with stream tracks:', 
        localStream.getTracks().map(t => `${t.kind} (${t.readyState})`).join(', '));
      
      // Connect as co-host with timeout
      const connectPromise = connectAsCoHost(id, localStream, videoRef.current);
      
      // First, check if stream is still live
      try {
        const { getFirestoreInstance } = await import('../services/firebase');
        const { doc, getDoc, updateDoc } = await import('firebase/firestore');
        const db = getFirestoreInstance();
        
        // Verify stream is still live before attempting to connect
        const streamRef = doc(db, 'liveStreams', id);
        const streamSnap = await getDoc(streamRef);
        
        if (!streamSnap.exists()) {
          throw new Error('Stream not found');
        }
        
        const streamData = streamSnap.data();
        if (streamData.status !== 'live') {
          console.warn(`‚ö†Ô∏è Stream status is ${streamData.status}, attempting to fix...`);
          
          // Try to refresh stream status if it's incorrectly marked as ended
          try {
            await updateDoc(streamRef, {
              status: 'live',
              lastSeen: new Date(),
              reconnectedAt: new Date().toISOString()
            });
            console.log('‚úÖ Fixed stream status back to live');
          } catch (err) {
            console.error('‚ùå Could not update stream status:', err);
            // Continue anyway, the connection might still work
          }
        }
      } catch (err) {
        console.warn('‚ö†Ô∏è Error checking stream status:', err);
        // Continue anyway, the connection might still work
      }

      // Race between connection and timeout
      const { pc, unsubAnswer, unsubHostICE } = await Promise.race([
        connectPromise,
        timeoutPromise as Promise<any>
      ]);
      
      console.log('‚úÖ Successfully connected as co-host!');
      
      // Set up cleanup function
      const cleanup = () => {
        try { unsubAnswer(); } catch (e) { console.error(e); }
        try { unsubHostICE(); } catch (e) { console.error(e); }
        try { pc.close(); } catch (e) { console.error(e); }
        try { stopLocalMedia(); } catch (e) { console.error(e); }
      };
      
      setCoHostCleanup(() => cleanup);
      setIsCoHost(true);
      setConnectionStatus('Co-hosting live!');
      
      // Add connection state monitoring
      pc.onconnectionstatechange = () => {
        console.log(`üîÑ Co-host connection state changed: ${pc.connectionState}`);
        if (pc.connectionState === 'connected') {
          setConnectionStatus('Connected to host - Live!');
        } else if (pc.connectionState === 'disconnected' || pc.connectionState === 'failed') {
          setConnectionStatus(`Connection ${pc.connectionState}. Try refreshing.`);
        }
      };
    } catch (error: any) {
      console.error('Failed to connect as co-host:', error);
      
      // Provide more helpful error messages
      let errorMessage = 'Failed to connect as co-host';
      
      if (error.message?.includes('Timeout waiting for host answer')) {
        errorMessage = 'Host did not respond to your join request. They may be busy or offline.';
      } else if (error.message?.includes('access')) {
        errorMessage = 'Camera/microphone access denied. Check your browser permissions.';
      } else if (error.message?.includes('Connection timeout')) {
        errorMessage = 'Connection timed out. The host may be offline or having network issues.';
      }
      
      setConnectionStatus(errorMessage);
      cleanupCoHostConnection();
    }
  };
  
  // Clean up co-host connection
  const cleanupCoHostConnection = () => {
    if (coHostCleanup) {
      coHostCleanup();
      setCoHostCleanup(null);
    }
    setIsCoHost(false);
  };
  
  // ref callback to detect when the <video> is mounted
  const setVideoRef = (el: HTMLVideoElement | null) => {
    videoRef.current = el;
    if (el && !videoReady) setVideoReady(true);
  };

  // debug: ◊ï◊ô◊ì◊ê◊ï ◊ê◊ú◊û◊†◊ò
  useEffect(() => {
    if (!videoRef.current) return;
    const v = videoRef.current;

    v.autoplay = true;
    v.playsInline = true;
    v.controls = true;
    // keep muted for autoplay compliance; audio can be toggled by user
    v.muted = true;

    v.onloadedmetadata = () => {
      console.log('üé• loadedmetadata', {
        w: v.videoWidth, h: v.videoHeight, duration: v.duration,
      });
    };
    
    // Log when video starts playing
    v.onplaying = () => {
      console.log('‚ñ∂Ô∏è Remote video is now playing');
    };
  }, [videoRef.current]);
  
  // Watch stream and get metadata
  useEffect(() => {
    if (!id) {
      setError('No stream ID provided');
      setLoading(false);
      return;
    }
    
    const db = getFirestoreInstance();
    const streamRef = doc(db, 'liveStreams', id);
    
    console.log(`üîç Watching stream metadata for ${id}`);
    setConnectionStatus('Loading stream information...');
    
    const unsub = onSnapshot(
      streamRef,
      (snapshot) => {
        if (!snapshot.exists()) {
          console.log('‚ùå Stream document not found');
          setError('Stream not found');
          setLoading(false);
          return;
        }
        
        const data = snapshot.data() as LiveStreamDoc;
        console.log('üìä Stream data:', data);
        setStreamData(data);
        
        if (data.status !== 'live') {
          console.log(`‚ö†Ô∏è Stream status is ${data.status}, not live`);
          setError(`This stream is no longer live (status: ${data.status})`);
          
          // Clean up any connection if stream ends
          if (isConnected) {
            console.log('üßπ Cleaning up connection as stream is no longer live');
            if (cleanupRef.current) cleanupRef.current();
            if (coHostCleanup) coHostCleanup();
            setIsConnected(false);
          }
        }
        
        setLoading(false);
      },
      (err) => {
        console.error('‚ùå Error watching stream:', err);
        setError(`Error loading stream: ${err.message}`);
        setLoading(false);
      }
    );

    return () => {
      console.log('üßπ Cleaning up stream listener');
      unsub();
      if (cleanupRef.current) {
        cleanupRef.current();
      }
      
      // Also clean up co-host connection if active
      if (coHostCleanup) {
        coHostCleanup();
      }
      
      // Clean up local media
      try { stopLocalMedia(); } catch (e) { console.error(e); }
    };
  }, [id]);

  // Attempt connection once all preconditions are met
  useEffect(() => {
    if (!id) return;
    if (isConnected) return;
    if (!videoRef.current || !videoReady) return;
    if (streamData?.status !== 'live') return;
    if (connectingRef.current) return;

    const el = videoRef.current;
    connectingRef.current = true;
    setConnectionStatus('Connecting to stream‚Ä¶');
    connectAsViewer(id, el)
      .then((result) => {
        console.log('‚úÖ Connection successful:', result);
        setIsConnected(true);
        setConnectionStatus('Connected to stream');
        cleanupRef.current = result.cleanup;
      })
      .catch((err: any) => {
        console.error('‚ùå Failed to connect:', err);
        setError(err.message || 'Failed to connect to stream');
        setConnectionStatus('Connection failed');
      })
      .finally(() => {
        connectingRef.current = false;
      });
  }, [id, videoReady, streamData?.status, isConnected]);

  const toggleFullscreen = () => {
    const el = containerRef.current || videoRef.current;
    if (!el) return;
    const d = document as any;
    if (!document.fullscreenElement) {
      (el as any).requestFullscreen?.() || (el as any).webkitRequestFullscreen?.();
    } else {
      d.exitFullscreen?.() || d.webkitExitFullscreen?.();
    }
  };

  if (loading) {
    return (
      <div className="pt-12 max-w-4xl mx-auto p-4">
        <div className="flex items-center justify-center h-64">
          <div className="w-8 h-8 border-4 border-blue-400 border-t-transparent rounded-full animate-spin mr-3" />
          <span className="text-lg font-medium">Loading stream...</span>
        </div>
      </div>
    );
  }

  if (error || !streamData) {
    return (
      <div className="pt-12 max-w-4xl mx-auto p-4">
        <div className="p-5 bg-red-50 border-2 border-red-200 rounded-lg shadow-md text-center">
          <h2 className="text-2xl font-bold text-red-700 mb-2">Stream Error</h2>
          <p className="text-red-600 mb-4">{error || 'This stream could not be loaded.'}</p>
          <Link
            to="/"
            className="px-4 py-2 bg-blue-500 hover:bg-blue-600 text-white rounded-md transition-colors inline-flex items-center"
          >
            <span className="mr-2">‚Üê</span> Back to Home
          </Link>
        </div>
      </div>
    );
  }

  return (
    <div className="pt-12 max-w-4xl mx-auto p-4">
      {/* Header */}
      <div className="flex items-center gap-3 mb-6 p-4 bg-white rounded-lg shadow-sm border border-gray-200">
        <UserAvatar
          photoURL={streamData.photoURL}
          displayName={streamData.displayName}
          email={streamData.displayName}
          size={48}
        />
        <div className="flex-1">
          <h1 className="text-xl font-semibold text-gray-800">{streamData.title || 'Live Stream'}</h1>
          <p className="text-gray-600">{streamData.displayName || 'Anonymous'}</p>
        </div>
        <div className="flex flex-col items-end gap-2">
          <div className="flex items-center">
            <span className="w-3 h-3 bg-red-500 rounded-full animate-pulse mr-2"></span>
            <span className="px-3 py-1 bg-gradient-to-r from-red-600 to-red-500 text-white text-sm font-medium rounded-full shadow-sm">LIVE</span>
          </div>
          
          {/* Request to Join Button */}
          {!isCoHost && (
            <RequestToJoinButton liveId={id} status={streamData.status} />
          )}
          
          {/* Leave stream button for co-hosts */}
          {isCoHost && (
            <div className="mt-2">
              <LeaveLiveButton onLeave={cleanupCoHostConnection} />
            </div>
          )}
        </div>
      </div>

      {/* Status */}
      <div className="mb-4 text-center">
        <div
          className={`inline-block px-3 py-1 rounded-full text-sm font-medium ${
            isConnected 
              ? 'bg-gradient-to-r from-green-600 to-green-500 text-white' 
              : 'bg-gradient-to-r from-yellow-600 to-yellow-500 text-white'
          }`}
        >
          {connectionStatus}
        </div>
      </div>

      {/* Video */}
      <div className="flex justify-center mb-6">
        {/* Video grid layout - changes based on co-hosting status */}
        <div className={`grid ${isCoHost ? 'grid-cols-2 gap-4 w-full max-w-[1200px]' : 'grid-cols-1 w-full max-w-[600px]'}`}>
          {/* Host Stream */}
          <div className="relative">
            <div className="aspect-video w-full rounded-lg overflow-hidden bg-black relative border-2 border-blue-300 shadow-lg">
              <video
                ref={setVideoRef}
                autoPlay
                playsInline
                controls
                muted
                className="w-full h-full object-contain bg-black"
                style={{ objectFit: 'contain' }}
                onLoadedMetadata={(e) => {
                  console.log('üìä Host video metadata loaded:', {
                    width: e.currentTarget.videoWidth,
                    height: e.currentTarget.videoHeight
                  });
                }}
                onPlay={() => {
                  console.log('‚ñ∂Ô∏è Host video is now playing');
                }}
              />

              {/* Fullscreen toggle */}
              <button
                type="button"
                onClick={toggleFullscreen}
                className="absolute top-2 right-2 z-10 px-2 py-1 text-xs rounded bg-black/60 text-white hover:bg-black/80"
                aria-label="Toggle fullscreen"
              >
                Fullscreen
              </button>
              
              {/* Host badge */}
              <div className="absolute top-2 left-2 z-10 px-3 py-1 text-xs rounded-full bg-gradient-to-r from-blue-600 to-blue-400 text-white font-bold shadow-sm">
                Host
              </div>
            </div>
          </div>

          {/* Co-host mode - show your own stream */}
          {isCoHost && localStream && (
            <div className="relative">
              <div className="aspect-video w-full rounded-lg overflow-hidden bg-black border-2 border-green-300 shadow-lg">
                <video
                  ref={localVideoRef}
                  autoPlay
                  playsInline
                  controls
                  muted
                  className="w-full h-full object-contain bg-black"
                />
                
                {/* Co-host badge */}
                <div className="absolute top-2 left-2 z-10 px-3 py-1 text-xs rounded-full bg-gradient-to-r from-green-600 to-green-400 text-white font-bold shadow-sm">
                  You (Co-host)
                </div>
              </div>
            </div>
          )}
        </div>
      </div>
      
      {/* Co-host status */}
      {isCoHost && (
        <div className="mt-4 mb-6 p-4 bg-gradient-to-r from-green-50 to-blue-50 border border-green-200 rounded-lg text-center shadow-sm">
          <p className="text-gray-800 font-medium">You're live with the host!</p>
          <p className="text-sm text-gray-600 mt-1">Your camera and microphone are being shared with viewers.</p>
        </div>
      )}
      
      {/* Join request status */}
      {joinRequest && joinRequest.status === 'pending' && (
        <div className="mt-4 mb-6 p-4 bg-gradient-to-r from-yellow-50 to-orange-50 border border-yellow-200 rounded-lg text-center shadow-sm">
          <p className="text-gray-800 font-medium">Your request to join is pending</p>
          <p className="text-sm text-gray-600 mt-1">Waiting for the host to approve your request...</p>
        </div>
      )}
      
      {joinRequest && joinRequest.status === 'rejected' && (
        <div className="mt-4 mb-6 p-4 bg-gradient-to-r from-red-50 to-pink-50 border border-red-200 rounded-lg text-center shadow-sm">
          <p className="text-gray-800 font-medium">Your request was declined</p>
          <p className="text-sm text-gray-600 mt-1">The host has declined your request to join.</p>
        </div>
      )}
      
      {/* Stream description */}
      {streamData.description && (
        <div className="mt-4 p-4 bg-white border border-gray-200 rounded-lg shadow-sm">
          <h2 className="text-lg font-medium text-gray-800 mb-2">About this stream</h2>
          <p className="text-gray-700">{streamData.description}</p>
        </div>
      )}
    </div>
  );
}
